. ~/.tq84-dotfile-sequence .bashrc

echo $(date) .bashrc: "\$- = $-" >> ~/.dotfile-sequence.log


if [[ "$-" != *i* ]]; then # { Check for interactive execution
# If not running interactively, don't do anything.
# .bashrc is also read during non-interactive SSH command
# execution which is whay it has a check at the beginning
# echo $(date) .bashrc: is not running interactively, so returning >> ~/.dotfile-sequence.log
  dot_file_log .bashrc "is not running interactively, so returning"
  return
fi # }
# echo $(date) .bashrc: Apparently running interactively, going on with script >> ~/.dotfile-sequence.log
dot_file_log .bashrc "Apparently running interactively, going on with script"

set -o vi

# Environment variables {

export git_work_dir=~/localgit/

# 2018-02-01 gone to profile
# export github_top_root=~/github/
# export github_root=${github_top_root}github/
export digitales_backup=$HOME/Digitales-Backup/
export ldp_dir=/home/rene/LDP/
export rn_root=$HOME/renenyffenegger.ch/
# }

# 2017-01-13
#
# history command number?
# PS1="\[\033[0;34m\]\w \[\033[0;35m\]\! \[\033[0m\]>"
#
# PS1 {
# username @ hostname

echo $(date) .bashrc: \$TERM=$TERM >> ~/.dotfile-sequence.log
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

if [ "$color_prompt" = yes ]; then
#   PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
    PS1="\[\e]0;\w\a\]\n\[\e[32m\]\u@\h \[\e[33m\]\w\[\e[0m\]\n\! \$ "
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt
# }

if [ -d ~/github/lib/scripts ]; then # {
  export PATH=~/github/lib/scripts:$PATH
fi # }

if [ -d ~/localgit/scripts ]; then # { add ~/localgit/scripts to PATH
  export PATH=~/localgit/scripts:$PATH
fi # }

if [ -d ${github_root}vim/runtime ]; then # { VIMRUNTIME
  export VIMRUNTIME=${github_root}vim/runtime
fi # }

if [ -d /media/rene/TOSHIBA\ EXT/git ]; then # { git_local_repo_dir, hd_mount_point
  dot_file_log .bash_rc "/media/rene/TOSHIBA EXT/git exists, exporting hd_mount_point"
  export hd_mount_point=/media/rene/TOSHIBA\ EXT/
elif [ -d /mnt/E/git ]; then # T420
  dot_file_log .bash_rc "/mnt/E exists, exporting hd_mount_point"
  export hd_mount_point=/mnt/E/
elif [ -d /cygdrive/f/git ]; then
  dot_file_log .bash_rc "/cygdrive/f/git exists, exporting hd_mount_point"
  export hd_mount_point=/cygdrive/f/git/
elif [ -d /cygdrive/x/git ]; then
  dot_file_log .bash_rc "/cygdrive/x/git exists, exporting hd_mount_point"
  export hd_mount_point=/cygdrive/x/git/
fi # }

# 2017-04-08
export git_local_repo_dir=${hd_mount_point}git/

# 2018-01-31: Oracle {
if [ "$ORACLE_HOME" ]; then
  dot_file_log .bashrc "ORACLE_HOME exists setting some aliases"

  alias sqlplus="rlwrap -r sqlplus "
  alias diag="cd $ORACLE_BASE/diag/rdbms/$ORACLE_UNQNAME/$ORACLE_SID/trace"

fi # }

# Ignore case of files in shell {
#   http://unix.stackexchange.com/a/48773/6479
shopt -s nocaseglob
# same thing in
#   yash:
#     set +o case-glob
#   zsh:
#     unsetopt CASE_GLOB
# }

# { History

export HISTIGNORE='*TQ84*'

# Don't put duplicate lines or lines starting with space in the history.
# Apparently, more options would be possible.
export HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

HISTSIZE=1000
HISTFILESIZE=2000

# }

if   [ "$(uname)" == "Darwin" ]; then # { Mac OS
    :

# }
elif [ "$(expr substr $(uname -s) 1 5)" == "Linux" ]; then # {

  alias v='gvim'

# 2017-07-23: Don't try to load change-layout if running cygwin - only if running Linux.
  if [ -e ${github_root}PostLinuxInstallation/keyboard/X/change-layout.sh ]; then # { key -> change-layout.sh
    alias key='${github_root}PostLinuxInstallation/keyboard/X/change-layout.sh'
    ${github_root}PostLinuxInstallation/keyboard/X/change-layout.sh
  else
    echo ${github_root}PostLinuxInstallation/keyboard/X/change-layout.sh does not exist!
  fi # }

# }
# elif [ "$(expr substr $(uname -s) 1 10)" == "MINGW32_NT" ]; then # { MSYS
# 2016-12-28: Is this elif (MINGW32_NT) still useful?
#
#      # ----- Windows NT platform.
#      #
#      # Assuming it's msys
#      # TODO: is it always Msys?
#
#   #  Make sure that Git does not always say
#   # «WARNING: terminal is not fully functional»
#
#      export TERM=msys
#
# # }
elif [ "$(uname -o)"  == "Cygwin" ] || [ "$(uname -o)" == "Msys" ]; then # {

#  TODO
#    Compare condition above with
#       if [[ $OSTYPE == *cygwin* ]]; then
#       fi

   # 2016-12-28: Allow backspace in «vi mode» to erase letter to the left:
   # 2016-12-29: Note, mintty.exe has the option »Backarrow sends ^H« (under Keys).
   #             Using this option might render the stty erase ^? unnecessary.
   stty erase ^?

   # 2016-12-29: vim doesn't seem to set MYVIMRC if started with -u
   #             Therefore, it's set from the outside
   alias v='MYVIMRC=~/.vim/vimrc vim  -u ~/.vim/vimrc'

   alias dospath='cygpath -w `pwd`'
   alias pc='dospath > /dev/clipboard'
   alias c:='cd /cygdrive/c'

   if [ "$(uname -o)" == "Cygwin" ]; then # {
     alias gvim='gvim -u ~/.vim/vimrc'
     export DISPLAY=:0.0
   fi # }

fi # }

# Alias {

alias ls='ls --color=auto'
alias ll='ls -lF'
alias la='ls -lFA'

alias info='info --vi-keys'
alias gitp=". gitp.sh"
alias gitl="git-pull.pl"
alias gits="git status ."
alias yt2mp3='youtube-dl --extract-audio --audio-format mp3 $1'
alias yt2mp4='youtube-dl --merge-output-format mp4 $1'
alias cdvimf='cd ~/.vim'
alias cdnot='cd $github_root/notes/notes'
alias cdhyd='cd $github_root/Hydroplattentheorie'
alias cdldp='cd $ldp_dir'
alias cdloc='cd ~/localgit'
alias cdkom='cd ${github_root}Bibelkommentare'
alias abc='abc.sh'
alias ghr='ghr.pl'
alias rs='Rscript'


# }
# Functions {

function fb() { # http://unix.stackexchange.com/questions/278732/is-there-a-standard-abbreviation-for-find-name-foo-or-do-i-need-a-function
  find . -iname "$1"
} # }

function mdcd() { # mkdir and cd into it
  dir=$1

  if [ -e "$dir" ]; then
    echo "File or directory $dir already exists";
    return
  fi

  mkdir "$dir"
  cd    "$dir"
} # }

function vwh() { # view (executable) script
  local f=$(which $1)
  if [ ! -f "$f" ]; then
     echo "File $f does not exist"
     return
  fi

  v "$f"
} # }

# }
